"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IgnoreInvulnerability = exports.Invulnerability = void 0;
const base_1 = require("./base");
const enums_1 = require("../../enums");
class Invulnerability extends base_1.Effect {
    constructor(data, caster) {
        super(data, caster);
        this.invulToFriendly = data.invulToFriendly || null;
        this.invulToHarmful = data.invulToHarmful || null;
        this.invulToSpecifSkill = data.invulToSpecifSkill || null;
        this.invulToSkillClass = data.invulToSkillClass || null;
    }
    functionality(char, origin) {
        const invul = char.getBuffs().invulnerability;
        const blockedInvul = char.getDebuffs().ignoreInvulnerability;
        const blockedBenefitial = char.getDebuffs().ignoreBenefitialEffects;
        if (blockedInvul || blockedBenefitial) {
            if (this.invulToSpecifSkill) {
                const skillName = this.arenaReference
                    .findCharacterById(this.caster)
                    .char.findSkillById(this.invulToSpecifSkill).name;
                invul.toSpecificSkill.add(this.invulToSpecifSkill);
                this.skillName = skillName;
            }
            return;
        }
        if (this.invulToFriendly)
            invul.toFriendly = true;
        else if (this.invulToHarmful)
            invul.toHarmful = true;
        else if (this.invulToSkillClass)
            invul.toSkillClass.add(this.invulToSkillClass);
        else if (this.invulToSpecifSkill) {
            const skillName = this.arenaReference
                .findCharacterById(this.caster)
                .char.findSkillById(this.invulToSpecifSkill).name;
            invul.toSpecificSkill.add(this.invulToSpecifSkill);
            this.skillName = skillName;
        }
    }
    generateToolTip() {
        if (this.invulToSpecifSkill) {
            this.message = `'${this.skillName}' can't be used on this character`;
        }
        else if (this.invulToSkillClass) {
            this.message = `This character is invulnerable to ${enums_1.SkillClassType[this.invulToSkillClass]} skills`;
        }
        else if (this.invulToHarmful) {
            this.message = `This character is invulnerable`;
        }
        else if (this.invulToFriendly) {
            this.message = `This character is invulnerable to friendly skills`;
        }
    }
}
exports.Invulnerability = Invulnerability;
class IgnoreInvulnerability extends base_1.Effect {
    constructor(data, caster) {
        super(data, caster);
    }
    functionality(char, origin) {
        //log.info(`[ANTI-INVULNERABILITY]: activated on ${char.name}`);
        char.getDebuffs().ignoreInvulnerability = true;
    }
    generateToolTip() {
        this.message = "This character cannot become invulnerable";
    }
}
exports.IgnoreInvulnerability = IgnoreInvulnerability;
//# sourceMappingURL=invulnerability.js.map